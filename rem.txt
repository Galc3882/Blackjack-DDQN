stand 0, 1 hit 2, 3

stand 0, 1 hit 2 double 3

stand 0 split 1 hit 2 double 3

insurance no 0, 1 yes 2, 3


#%%

class CardGameEnv(tf_py_environment.TFPyEnvironment):
    def __init__(self):
        self._action_spec = array_spec.BoundedArraySpec(
            shape=(), dtype=np.int32, minimum=0, maximum=3, name='action')
        self._observation_spec = array_spec.BoundedArraySpec(
            shape=(13,), dtype=np.int32, minimum=0, maximum=13, name='observation')
        self._episode_ended = False
        self._state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        self.creamcolor = [255, 253, 208]

        self.cardpack = []
        self.dealercards = []
        self.splitdealercard = []
        self.playercards = []
        self.lastpacksize = 0

        self.running = True
        self.start = True
        
        self.lastkeypressed = None
        self.firstmove = False
        self.score = 0
        self.lastscore = 0

        self.debugvar = True

        self.isstand = False
        self.cansplit = False
        self.issplit = 0
        self.splitcard = 0

        self.isdouble = 0
        self.candouble = False

        self.nextafterinsu = False

        #self.__start()

    """
    def __start(self):
        self.isstand = False
        self.firstmove = True
        self.candouble = True
        self.lastscore = self.score
        self.playercards, self.dealercards, self.cardpack = initgame(self.playercards, self.dealercards, self.cardpack)
        while totalcards(self.playercards)[0] > 21:
            initgame()
        
        #if debugvar == True:
            #dealercards = [10, 1]
            #dealercards[0] = 1
            #playercards = [10, 1]
            #playercards[1] = playercards[0]
            #debugvar = False
        
        drawstarttext(self.playercards, self.score, self.creamcolor)
        
        # draws this if didnt lose at the start
        drawfirstdealercard(self.dealercards, self.creamcolor)

        # check split
        if (self.playercards[0] == self.playercards[1] or (max(totalcards(self.playercards)) == 20 and self.playercards[0] > 9)) and self.issplit == 0:
            self.cansplit = True
        elif self.issplit == 1 and self.firstmove == True:
            self.cardpack, self.playercards, self.dealercards, self.splitcard, self.splitdealercard, self.issplit = split(
                self.cardpack, self.playercards, self.dealercards, self.splitcard, self.splitdealercard, self.issplit)

        self._state = [self.dealercards[0]]
        for i in self.playercards:
            self._state.append(i)
        self._state.extend([0] * (13 - len(self._state)))
        print(str(self._state))
    """

    def action_spec(self):
        return self._action_spec

    def observation_spec(self):
        return self._observation_spec

    def _reset(self):
        #self.__start()
        self._episode_ended = False
        return ts.restart(np.array([self._state], dtype=np.int32))

    def _step(self, action):

        if self._episode_ended:
            # The last action ended the episode. Ignore the current action and start
            # a new episode.
            return self.reset()

        """
        action = 5
        if action < 0 or action > 3:
            print(str(action))
            raise ValueError('`action` should be 0 to 3.')
        """

        self._episode_ended = True
        return ts.termination(np.array([self._state], dtype=np.int32), 0)

        """
        self.nextafterinsu = False

        if self.start == True and self.running == True:
            self.start = False

            # check natural
            self.start, self.running, self.score = checknatural(
                self.dealercards, self.playercards, self.score, self.start, self.running, self.action)
            if self.running == False:
                #break
                pass
        
                
        self.lastpacksize = showpacksize(self.lastpacksize)

        if self.running == True and self.start == False and self.nextafterinsu == False:
            if max(totalcards(self.playercards)) != 21:
                self.running, self.isstand, self.cansplit, self.issplit, self.candouble, self.isdouble = asknextmove(
                    self.running, self.isstand, self.cansplit, self.issplit, self.candouble, self.isdouble, self.action)
                if self.issplit == 2 and self.firstmove == True:
                    self.cardpack, self.playercards, self.dealercards, self.splitcard, self.splitdealercard, self.issplit = split(
                        self.cardpack, self.playercards, self.dealercards, self.splitcard, self.splitdealercard, self.issplit)
                self.start, self.running, self.score, self.isdouble = checkbust(self.start, self.running, self.score, self.isdouble)
                if len(self.playercards) > 5 and self.start == False:
                    self.start, self.running, self.score = dealerlose(self.score)
            else:
                self.isstand = True

            self.firstmove = False

            if self.isstand == True and self.start == False:
                self.isstand = False
                self.start, self.running, self.score = dealermove(self.start, self.running, self.score)
                if start == False and running == True:
                    if max(totalcards(self.dealercards)) > max(totalcards(self.playercards)):
                        self.start, self.running, self.score = playerlose(self.score)
                    elif max(totalcards(self.dealercards)) == max(totalcards(self.playercards)):
                        self.start, self.running = tie()
                    else:
                        self.start, self.running, self.score = dealerlose(self.score)
                if self.isdouble == 1:
                    self.isdouble = 0
                    self.score += self.score - self.lastscore

            self._state = [self.dealercards[0]]
            for i in self.playercards:
                self._state.append(i)
            self._state.extend([0] * (13 - len(self._state)))
            print(str(self._state))
        
        # Make sure episodes don't go on forever.
        if self.start == True:
            self._episode_ended = True
            self._state = None
            for i in self.dealercards:
                self._state.append(i)
            for i in self.playercards:
                self._state.append(i)
            self._state.extend([0] * (13 - len(self._state)))
            print(str(self._state))
            reward = self.score - self.lastscore
            return ts.termination(np.array([self._state], dtype=np.int32), reward)
        else:
            return ts.transition(np.array([self._state], dtype=np.int32), reward=0.0, discount=1.0)
            """
#%%